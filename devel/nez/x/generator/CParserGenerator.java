package nez.x.generator;

import nez.lang.Expression;
import nez.lang.Production;
import nez.lang.expr.Cany;
import nez.lang.expr.Cbyte;
import nez.lang.expr.Cmulti;
import nez.lang.expr.Cset;
import nez.lang.expr.NonTerminal;
import nez.lang.expr.Pand;
import nez.lang.expr.Pchoice;
import nez.lang.expr.Pnot;
import nez.lang.expr.Pone;
import nez.lang.expr.Poption;
import nez.lang.expr.Psequence;
import nez.lang.expr.Pzero;
import nez.lang.expr.Tcapture;
import nez.lang.expr.Tdetree;
import nez.lang.expr.Tlfold;
import nez.lang.expr.Tlink;
import nez.lang.expr.Tnew;
import nez.lang.expr.Treplace;
import nez.lang.expr.Ttag;
import nez.lang.expr.Xblock;
import nez.lang.expr.Xdefindent;
import nez.lang.expr.Xexists;
import nez.lang.expr.Xif;
import nez.lang.expr.Xindent;
import nez.lang.expr.Xis;
import nez.lang.expr.Xlocal;
import nez.lang.expr.Xmatch;
import nez.lang.expr.Xon;
import nez.lang.expr.Xsymbol;
import nez.parser.GenerativeGrammar;
import nez.parser.ParserGenerator;

public class CParserGenerator extends ParserGenerator {

	@Override
	protected String getFileExtension() {
		return "c";
	}

	private final CParserGenerator Include(String path) {
		L("#include \"" + path + "\"");
		return this;
	}

	private final CParserGenerator Define(String macro) {
		L("#define " + macro);
		return this;
	}

	private final CParserGenerator Comment(String comment) {
		L("// " + comment);
		return this;
	}

	private final CParserGenerator Begin() {
		L("{");
		file.incIndent();
		return this;
	}

	private final CParserGenerator End() {
		file.decIndent();
		L("}");
		return this;
	}

	protected CParserGenerator N() {
		this.file.writeNewLine();
		return this;
	}

	private final CParserGenerator Prototype(String type, String name, String... args) {
		L(type + " " + name + "(");
		for (int i = 0; i < args.length; i++) {
			W(args[i]);
		}
		W(");");
		return this;
	}

	private final CParserGenerator Func(String type, String name, String... args) {
		L(type + " " + name + "(");
		for (int i = 0; i < args.length; i++) {
			W(args[i]);
		}
		W(")");
		return this;
	}

	private final CParserGenerator FuncCall(String name, String... args) {
		L(name + "(");
		for (int i = 0; i < args.length; i++) {
			W(args[i]);
		}
		W(")");
		return this;
	}

	private final CParserGenerator Let(String type, String name, String expr) {
		L(type + " " + name + " " + expr + ";");
		return this;
	}

	private final CParserGenerator If(String expr) {
		L("if(" + expr + ")");
		return this;
	}

	private final String _Equals(String left, String right) {
		return left + " == " + right;
	}

	private final String _NotEquals(String left, String right) {
		return left + " == " + right;
	}

	private final CParserGenerator Consume() {
		L("ctx->pos++;");
		return this;
	}

	@Override
	public void makeHeader(GenerativeGrammar gg) {
		final String __FILE__ = new Throwable().getStackTrace()[1].getFileName();
		Comment("This file is auto generated by nez.jar");
		Comment("If you want to fix something, you must edit " + __FILE__);
		L();
		Include("cnez.h");
		for (Production r : gg.getProductionList()) {
			if (!r.getLocalName().startsWith("\"")) {
				Prototype("int", "p" + name(r.getLocalName()), "ParsingContext ctx");
			}
		}
		L();
	}

	@Override
	public void makeFooter(GenerativeGrammar gg) {
		int flagTableSize = 0 /* this.flagTable.size() */;
		int prodSize = gg.getProductionList().size();
		// L("#define CNEZ_FLAG_TABLE_SIZE " + flagTableSize);
		Define("CNEZ_FLAG_TABLE_SIZE " + flagTableSize);
		// L("#define CNEZ_MEMO_SIZE " + 0 /* this.memoId */);
		Define("CNEZ_MEMO_SIZE       " + 0 /* this.memoId */);
		// L("#define CNEZ_GRAMMAR_URN \"" + urn + "\"");
		// L("#define CNEZ_PRODUCTION_SIZE " + prodSize);
		Define("CNEZ_PRODUCTION_SIZE " + prodSize);
		if (this.enabledASTConstruction) {
			// L("#define CNEZ_ENABLE_AST_CONSTRUCTION 1");
			Define("CNEZ_ENABLE_AST_CONSTRUCTION 1");
		}
		// L("#include \"cnez_main.c\"");
		Include("cnez_main.c");
	}

	int fid = 0;

	class FailurePoint {
		int id;
		FailurePoint prev;

		public FailurePoint(int label, FailurePoint prev) {
			this.id = label;
			this.prev = prev;
		}
	}

	FailurePoint fLabel;

	private CParserGenerator initFalureJumpPoint() {
		this.fid = 0;
		this.fLabel = null;
		return this;
	}

	private CParserGenerator pushFailureJumpPoint() {
		this.fLabel = new FailurePoint(this.fid++, this.fLabel);
		return this;
	}

	private CParserGenerator popFailureJumpPoint(Production r) {
		Label("CATCH_FAILURE" + this.fLabel.id);
		this.fLabel = this.fLabel.prev;
		return this;
	}

	private CParserGenerator popFailureJumpPoint(Expression e) {
		Label("CATCH_FAILURE" + this.fLabel.id);
		this.fLabel = this.fLabel.prev;
		return this;
	}

	private CParserGenerator jumpFailureJump() {
		return gotoLabel("CATCH_FAILURE" + this.fLabel.id);
	}

	private CParserGenerator jumpPrevFailureJump() {
		return gotoLabel("CATCH_FAILURE" + this.fLabel.prev.id);
	}

	private CParserGenerator gotoLabel(String label) {
		L("goto " + label + ";");
		return this;
	}

	private CParserGenerator Label(String label) {
		N();
		W(label + ": ;");
		return this;
	}

	@Override
	public void visitProduction(GenerativeGrammar gg, Production p) {
		initFalureJumpPoint();
		// L("int p" + name(p.getLocalName()) + "(ParsingContext ctx)");
		Func("int", "p" + name(p.getLocalName()), "ParsingContext ctx");
		Begin();
		pushFailureJumpPoint();
		// if (this.enabledPackratParsing) {
		// lookup(p, this.memoId);
		// }
		String pos = "c" + this.fid;
		Let("char *", pos, "ctx->cur");
		Expression e = p.getExpression();
		visitExpression(e);
		// if (this.enabledPackratParsing) {
		// memoize(p, this.memoId, pos);
		// }
		L("return 0;");
		popFailureJumpPoint(p);
		// if (this.enabledPackratParsing) {
		// memoizeFail(p, this.memoId, pos);
		// }
		L("return 1;");
		End();
		L();
		// if (this.enabledPackratParsing) {
		// this.memoId++;
		// }
	}

	@Override
	public void visitPempty(Expression p) {
	}

	@Override
	public void visitPfail(Expression p) {
		jumpFailureJump();
	}

	@Override
	public void visitCany(Cany p) {
		If(_Equals("*ctx->cur", "0")).Begin();
		jumpFailureJump();
		End();
		Consume();
	}

	@Override
	public void visitCbyte(Cbyte p) {
		If(_NotEquals("*ctx->cur", String.valueOf(p.byteChar)));
		Begin();
		this.jumpFailureJump();
		End();
		Consume();
	}

	@Override
	public void visitCset(Cset p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitCmulti(Cmulti p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPoption(Poption p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPzero(Pzero p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPone(Pone p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPand(Pand p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPnot(Pnot p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPsequence(Psequence p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitPchoice(Pchoice p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitNonTerminal(NonTerminal p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTlink(Tlink p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTnew(Tnew p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTlfold(Tlfold p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTcapture(Tcapture p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTtag(Ttag p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTreplace(Treplace p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitTdetree(Tdetree p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXblock(Xblock p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXlocal(Xlocal p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXdef(Xsymbol p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXexists(Xexists p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXmatch(Xmatch p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXis(Xis p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXif(Xif p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXon(Xon p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXdefindent(Xdefindent p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitXindent(Xindent p) {
		// TODO Auto-generated method stub

	}

}
